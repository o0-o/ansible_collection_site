---
# vim: ts=2:sw=2:sts=2:et:ft=yaml.ansible
#
# Save interface configuration to Linux host
#
########################################################################

- name: Get service information
  ansible.builtin.service_facts:

- name: Try Network Manager and fallback to networkd
  block:

  - name: Network Manager is available
    ansible.builtin.assert:
      that: services['NetworkManager.service']['state'] == 'running'
      quiet: true

  # Configure Network Manager
  - name: "Naming connection {{nm_con_name_var}}"
    ansible.builtin.set_fact:
      nm_con_name: "{{nm_con_name_var}}"
    vars:
      nm_con_name_var: "{{  current_iface['mac_addr']
                            | default(current_iface['dev'])
                            | regex_replace(':', '-') }}"

  - block:

    - name: "The {{nm_con_name}} connection exists"
      ansible.builtin.shell:
        cmd: nmcli connection show {{nm_con_name}}
      changed_when: false
      become: true

    rescue:

    - ansible.builtin.debug:
        msg: "{{nm_con_name}} is a new connection"

    # Don't delete any connections until new connection is configured
    - name: >
        Mark any pre-existing connections associated with
        {{current_iface['dev']}} for deletion
      ansible.builtin.shell:
        cmd: >
          nmcli --get-values 'uuid,device' connection show |
          grep '{{current_iface['dev']}}$' |
          cut -d ':' -f 1
      changed_when: false
      become: true
      register: con_to_delete_reg

  - name: The connection type is ethernet (physical interface)
    ansible.builtin.set_fact:
      nm_iface_type: ethernet
    when: current_iface == iface_item

  - name: The connection type is VLAN
    ansible.builtin.set_fact:
      nm_iface_type: vlan
    when: current_iface == vlan_item | default()

  # The nmcli module seems insistent that certain parameters are set in
  # the presence of others, so instead of gradually building the
  # configuration, the entire interface is configured in one command.
  # Unfortunately, this necessitates some repitition as well as compound
  # conditionals for different interface configurations.

  - name: >
      Configure {{nm_con_name}} ({{current_iface['dev']}}) as a physical
      interface with no IP address
    community.general.nmcli:
      conn_name: "{{nm_con_name}}"
      ifname: "{{current_iface['dev']}}"
      type: "{{nm_iface_type}}"
      autoconnect: true
      mtu: "{{current_mtu}}"
      state: present
    become: true
    when:
    - nm_iface_type == 'ethernet'
    - current_iface_ip | default('') == ''
    notify: restart network

  - name: >
      Configure {{nm_con_name}} ({{current_iface['dev']}}) as a physical
      interface with DHCP
    community.general.nmcli:
      conn_name: "{{nm_con_name}}"
      ifname: "{{current_iface['dev']}}"
      type: "{{nm_iface_type}}"
      autoconnect: true
      mtu: "{{current_mtu}}"
      method4: auto
      dhcp_client_id: duid
      state: present
    become: true
    when:
    - nm_iface_type == 'ethernet'
    - current_iface_ip | default('') | lower == 'dhcp'
    notify: restart network

  - name: >
      Configure {{nm_con_name}} ({{current_iface['dev']}}) as a physical
      interface with IP {{current_iface_ip}}
    community.general.nmcli:
      conn_name: "{{nm_con_name}}"
      ifname: "{{current_iface['dev']}}"
      type: "{{nm_iface_type}}"
      autoconnect: true
      mtu: "{{current_mtu}}"
      method4: manual
      ip4: "{{current_iface_ip}}/{{current_mask}}"
      state: present
    become: true
    when:
    - nm_iface_type == 'ethernet'
    - current_iface_ip | default() | ansible.netcommon.ipv4
    - current_net['route'][0] is undefined
    notify: restart network

  # Passing an empy list to routes results in an error. Passing a
  # list containing a single empty string succeeds but ceases to be
  # idempotent (it is marked as changed even when all configuration has
  # already been applied). Thus, we have to create yet another case for
  # when routes exist.
  - name: >
      Configure {{nm_con_name}} ({{current_iface['dev']}}) as a physical
      interface with IP {{current_iface_ip}} with routes
    community.general.nmcli:
      conn_name: "{{nm_con_name}}"
      ifname: "{{current_iface['dev']}}"
      type: "{{nm_iface_type}}"
      autoconnect: true
      mtu: "{{current_mtu}}"
      method4: manual
      ip4: "{{current_iface_ip}}/{{current_mask}}"
      routes4: "{{  current_net['route']
                    | map('dict2items')
                    | map('map', attribute='value')
                    | map('join', ' ')
                    | regex_replace('0/0', '0.0.0.0/0')
                    | regex_replace('default', '0.0.0.0/0') }}"
      state: present
    become: true
    when:
    - nm_iface_type == 'ethernet'
    - current_iface_ip | default() | ansible.netcommon.ipv4
    - current_net['route'][0] is defined
    notify: restart network

  - name: "Configure {{current_iface['dev']}} as a VLAN with DHCP"
    community.general.nmcli:
      conn_name: "{{nm_con_name}}"
      type: "{{nm_iface_type}}"
      vlandev: "{{iface_item['dev']}}"
      vlanid: "{{current_net['id']}}"
      autoconnect: true
      mtu: "{{current_mtu}}"
      method4: auto
      dhcp_client_id: duid
      state: present
    become: true
    when:
    - nm_iface_type == 'vlan'
    - current_iface_ip | default() | lower == 'dhcp'
    notify: restart network

  - name: >
      Configure {{current_iface['dev']}} as a VLAN with IP {{current_iface_ip}}
    community.general.nmcli:
      conn_name: "{{nm_con_name}}"
      type: "{{nm_iface_type}}"
      vlandev: "{{iface_item['dev']}}"
      vlanid: "{{current_net['id']}}"
      autoconnect: true
      mtu: "{{current_mtu}}"
      method4: manual
      ip4: "{{current_iface_ip}}/{{current_mask}}"
      state: present
    become: true
    when:
    - nm_iface_type == 'vlan'
    - current_iface_ip | default() | ansible.netcommon.ipv4
    - current_net['route'][0] is undefined
    notify: restart network

  - name: >
      Configure {{current_iface['dev']}} as a VLAN with IP {{current_iface_ip}}
      and routes
    community.general.nmcli:
      conn_name: "{{nm_con_name}}"
      type: "{{nm_iface_type}}"
      vlandev: "{{iface_item['dev']}}"
      vlanid: "{{current_net['id']}}"
      autoconnect: true
      mtu: "{{current_mtu}}"
      method4: manual
      ip4: "{{current_iface_ip}}/{{current_mask}}"
      routes4: "{{  current_net['route']
                    | map('dict2items')
                    | map('map', attribute='value')
                    | map('join', ' ')
                    | regex_replace('0/0', '0.0.0.0/0')
                    | regex_replace('default', '0.0.0.0/0') }}"
      state: present
    become: true
    when:
    - nm_iface_type == 'vlan'
    - current_iface_ip | default() | ansible.netcommon.ipv4
    - current_net['route'][0] is defined
    notify: restart network

  # The nmcli module only allows random mac on wifi type interfaces so
  # we configure it manually.
  - name: "Randomize {{current_iface['dev']}} MAC address"
    block:

    - name: "{{current_iface['dev']}} MAC address is already randomized"
      ansible.builtin.shell:
        cmd: >
          nmcli --get-values 802-3-ethernet.cloned-mac-address connection show
          {{nm_con_name}}
      become: true
      register: mac_addr_rand_reg
      changed_when: false
      failed_when: mac_addr_rand_reg['stdout_lines'][0] | default() != 'random'

    rescue:

    - name: "Configure random MAC address for {{current_iface['dev']}}"
      ansible.builtin.shell:
        cmd: >
          nmcli connection modify {{nm_con_name}}
          802-3-ethernet.cloned-mac-address random
      become: true
      when: not ansible_check_mode
      notify: restart network

    when: current_iface['random_mac'] | default(true)

  - name: Flush handlers to bring up any newly configured interfaces
    ansible.builtin.meta: flush_handlers

  - name: "Delete any conflicting connections using {{current_iface['dev']}}"
    ansible.builtin.shell:
      cmd: "nmcli connection delete {{con_item}}"
    become: true
    loop: "{{con_to_delete_reg['stdout_lines'] | default([]) }}"
    loop_control:
      loop_var: con_item
    notify: restart network

  # Ensure conflicting network services are stopped and disabled
  - name: Stop and disable systemd-networkd.service
    ansible.builtin.service:
      name: systemd-networkd.service
      state: stopped
      enabled: no
    become: true
    when: srv_status_var != 'not-found'
    notify: update service facts
    vars:
      srv_status_var: "{{ services['systemd-networkd.service']['status']
                          | default('not-found') }}"

  rescue:

  - name: Only fall back to networkd if Network Manager isn't running
    ansible.builtin.assert:
      that: >
        services['NetworkManager.service']['state'] | default() != 'running'
      quiet: true

  - name: Enable networkd
    ansible.builtin.service:
      name: systemd-networkd
    become: true

  - name: "Configure {{netdev_var}}"
    ansible.builtin.template:
      src: networkd/iface.netdev.j2
      dest: "{{netdev_var}}"
      owner: root
      group: root
      mode: 0644
      backup: true
    become: true
    when: vlan_item is defined
    notify: restart network
    vars:
      netdev_var: "/etc/systemd/network/00_{{current_iface['dev']}}.netdev"

  - name: "Configure {{link_var}}"
    ansible.builtin.template:
      src: networkd/iface.link.j2
      dest: "{{link_var}}"
      owner: root
      group: root
      mode: 0644
      backup: true
    become: true
    notify: restart network
    vars:
      link_var: "\
        /etc\
        /systemd\
        /network\
        /00_{{ current_iface['mac_addr']
              | default(current_iface['dev'])
              | regex_replace(':', '-') }}.link"

  - name: "Configure {{net_var}}"
    ansible.builtin.template:
      src: networkd/iface.network.j2
      dest: "{{net_var}}"
      owner: root
      group: root
      mode: 0644
      backup: true
    become: true
    notify: restart network
    vars:
      net_var: "\
        /etc\
        /systemd\
        /network\
        /00_{{ current_iface['mac_addr']
              | default(current_iface['dev'])
              | regex_replace(':', '-') }}.network"

# We don't support ifupdown
- name: Stop and disable networking.service
  ansible.builtin.service:
    name: networking.service
    state: stopped
    enabled: no
  become: true
  when: srv_status_var != 'not-found'
  notify: update service facts
  vars:
    srv_status_var: "{{ services['networking.service']['status']
                        | default('not-found') }}"

- name: Flush handlers to bring up any newly configured interfaces
  ansible.builtin.meta: flush_handlers
